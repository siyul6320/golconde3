<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Digital Golconda - Final Integration</title>
  <style>
    * {
      box-sizing: border-box;
    }
    
    /* í—¤ë”(ì»¨íŠ¸ë¡¤ ë°”) ìŠ¤íƒ€ì¼ */
    header.controls {
      position: absolute;
      top: 48%;
      left: 50%;
      transform: translate(-50%, calc(-50% - 250px));
      z-index: 10;
      display: flex;
      align-items: center;
      background-color: rgba(255, 255, 255, 0.85);
      border: none;
      border-radius: 26px;
      /* ğŸ’¡ ìˆ˜ì •: ë³¼ë¥¨ ìŠ¬ë¼ì´ë” ê³µê°„ í™•ë³´ë¥¼ ìœ„í•´ ë„ˆë¹„ ì¦ê°€ (520px -> 650px) */
      width: 650px; 
      max-width: 95vw;
      height: 46px;
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
    }
    
    .container:hover header.controls {
      opacity: 1;
      pointer-events: auto;
    }
    
    /* ê³µí†µ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
    button { cursor: pointer; }
    button:focus { outline: none; }
    button:hover { background-color: rgb(230, 230, 230); color: black; }

    /* ëª¨ë“œ í† ê¸€ ë²„íŠ¼ */
    .toggle-mode {
      padding: 0px 20px;
      border: none;
      background-color: rgb(240, 240, 240);
      margin-left: 10px;
      color: black;
      border-radius: 15px;
      font-weight: bold;
      height: 32px;
      width: 80px; /* ê³ ì • ë„ˆë¹„ë¡œ ë³€ê²½í•˜ì—¬ ë ˆì´ì•„ì›ƒ í”ë“¤ë¦¼ ë°©ì§€ */
    }
    
    .toggle-mode.active {
      background-color: rgb(240, 240, 240);
      color: black;
    }
    
    /* ì…€ë ‰íŠ¸ ë°•ìŠ¤ ë˜í¼ (í…Œë§ˆ, ì†Œë¦¬) */
    .select-wrapper {
      position: relative;
      display: inline-block;
      margin-left: 5px;
    }

    /* í…Œë§ˆ ì„ íƒ ì…€ë ‰íŠ¸ */
    .season-select {
      padding: 0px 15px;
      border: none;
      background-color: white;
      color: black;
      border-radius: 20px;
      font-weight: bold;
      cursor: pointer;
      height: 32px;
      width: 122px;
      padding-right: 40px; /* ë²„íŠ¼ ê³µê°„ */
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      outline: none;
    }
    
    /* ì¬ìƒ/ì¼ì‹œì •ì§€ ë²„íŠ¼ (í…Œë§ˆ ì˜†) */
    .play-pause {
      position: absolute;
      border: none;
      padding: 6px 0px 4px 2px; /* í…ìŠ¤íŠ¸ ì¤‘ì•™ ì •ë ¬ ë¯¸ì„¸ ì¡°ì • */
      font-size: 14px;
      background-color: rgb(240, 240, 240);
      color: black;
      border-radius: 50%;
      width: 34px;
      height: 32px;
      right: -1px; 
      top: 50%;
      transform: translateY(-50%);
      pointer-events: auto;
      display: flex; 
      justify-content: center; 
      align-items: center;
    }

    /* ì†Œë¦¬ ì„ íƒ ì…€ë ‰íŠ¸ */
    .sound-select {
      padding: 0px 15px;
      border: none;
      background-color: white;
      color: black;
      border-radius: 20px;
      font-weight: bold;
      cursor: pointer;
      height: 32px;
      width: 132px;
      padding-right: 40px;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    
    .sound-select:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* ì†Œë¦¬ On/Off ë²„íŠ¼ */
    .sound-btn {
      position: absolute;
      border: none;
      padding: 0;
      font-size: 16px;
      background-color: rgb(240, 240, 240);
      border-radius: 50%;
      width: 34px;
      height: 32px;
      right: -1px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: auto;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .sound-btn:hover { background-color: rgb(230, 230, 230); }

    /* ğŸ”Š [NEW] ë³¼ë¥¨ ìŠ¬ë¼ì´ë” ìŠ¤íƒ€ì¼ */
    .volume-slider {
      -webkit-appearance: none;
      width: 80px;
      height: 4px;
      background: #ddd;
      border-radius: 5px;
      outline: none;
      margin-left: 10px;
      margin-right: 10px;
      cursor: pointer;
    }
    
    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #666;
      cursor: pointer;
      transition: background .15s ease-in-out;
    }
    
    .volume-slider::-webkit-slider-thumb:hover {
      background: #333;
    }

    /* ìš°ì¸¡ ë²„íŠ¼ë“¤ (ì •ë³´, ì „ì²´í™”ë©´) */
    .right-controls {
      display: flex;
      margin-left: auto; /* ìš°ì¸¡ ì •ë ¬ */
      padding-right: 10px;
      gap: 5px;
    }

    .info-btn, .fullscreen-btn {
      border: none;
      font-size: 16px;
      background-color: rgb(240, 240, 240);
      cursor: pointer;
      border-radius: 50%;
      width: 34px;
      height: 32px;
      font-weight: bold;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* ì „ì²´í™”ë©´ ì •ë³´ íŒ¨ë„ */
    .fullscreen-info {
      display: none;
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      background-color: rgba(255, 255, 255, 0.85);
      padding: 10px 30px 14px 30px;
      border-radius: 25px;
      text-align: center;
    }
    
    .fullscreen-info.show { display: block; }
    
    .fullscreen-time {
      font-size: 20px;
      font-weight: bold;
      color: rgba(111, 112, 112, 0.8);
      margin-top: 5px;
    }
    
    /* ì „ì²´í™”ë©´ ëª¨ë“œ ì‹œ í—¤ë” ìˆ¨ê¸°ê¸° */
    body.fullscreen-mode header.controls {
      display: none !important;
    }
    body.fullscreen-mode canvas {  
width: 100vw !important;
 height: 100vh !important;
}
    
    /* ê¸°ë³¸ ë ˆì´ì•„ì›ƒ */

    body {
      background: #333;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      font-family: 'Pretendard', sans-serif; /* í°íŠ¸ í†µì¼ */
    }

    .container {
      display: flex;
      gap: 20px;
      position: relative; /* hover ê°ì§€ë¥¼ ìœ„í•´ */
    }

    canvas { background: #000; }

    /* CSS ë°°ê²½ í´ë˜ìŠ¤ë“¤ */
    .box1 { background-image: linear-gradient(360deg, rgba(218, 230, 237, 1) 0%, rgba(233, 195, 178, 1) 20%, rgba(159, 166, 199, 1) 73%, rgba(146, 152, 184, 1) 100%); }
    .box2 { background-image: linear-gradient(180deg, rgba(162, 197, 237, 1) 61%, rgba(246, 235, 143, 1) 100%); }
    .box3 { background: linear-gradient(180deg, rgba(251, 209, 141, 1) 0%, rgba(174, 223, 245, 1) 31%); }
    .box4 { background-image: linear-gradient(180deg, rgba(86, 149, 179, 1) 0%, rgba(196, 189, 154, 1) 83%, rgba(251, 209, 141, 1) 100%); }
    .box5 { color: white; background-image: linear-gradient(180deg, rgba(25, 26, 31, 1) 0%, rgba(121, 155, 189, 1) 100%, rgba(62, 92, 117, 1) 52%); }

    /* í”„ë¡œì íŠ¸ ì •ë³´ íŒ¨ë„ */
    .project-info {
      display: none;
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(55px); 
      z-index: 100;
      background-color: rgba(255, 255, 255, 0.95);
      border-radius: 12px;
      padding: 12px 10px 12px 12px;
      width: 345px;       
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .project-info.show {
      display: block;
      animation: fadeIn 0.3s forwards;
    }

    .info1 { padding: 0px; margin: 5px; color: black; font-size: 12px; font-weight: bold; }
    .info { padding: 0px; margin: 5px; color: #828282; font-size: 12px; }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(55px) translateY(-10px); }
      to { opacity: 1; transform: translateX(55px) translateY(0); }
    }

    body.fullscreen-mode .project-info { display: none !important; }
  </style>
</head>
<body>

  <div class="container">
    <canvas id="mainCanvas" width="800" height="600"></canvas>

    <header class="controls">
      <button class="toggle-mode active" id="realtimeBtn">ìˆ˜ë™</button>
      
      <div class="select-wrapper">
        <select class="season-select" id="seasonSelect">
          <option selected disabled>í…Œë§ˆ ì„ íƒ</option>
          <option value="spring">ë´„</option>
          <option value="summer">ì—¬ë¦„</option>
          <option value="autumn">ê°€ì„</option>
          <option value="winter">ê²¨ìš¸</option>
          <option value="rain">ì¥ë§ˆ</option>
          <option value="Christmas">í¬ë¦¬ìŠ¤ë§ˆìŠ¤</option>
        </select>
        <button class="play-pause" id="playBtn">â–¶</button>
      </div>
      
      <div class="select-wrapper">
        <select class="season-select sound-select" id="soundSelect">
          <option disabled selected>ì†Œë¦¬ ì„ íƒ</option>
          <option value="forest">ìˆ²</option>
          <option value="bird">ìƒˆ</option>
          <option value="ocean">ë°”ë‹¤</option>
          <option value="fallen_leaves">ë‚™ì—½</option>
          <option value="rain">ë¹„</option>
          
          <option value="bonfire">ëª¨ë‹¥ë¶ˆ</option>
          <option value="restanrant">ì‹ë‹¹</option>
          <option value="cafe">ì¹´í˜</option>
        </select>
        <button class="sound-btn" id="soundBtn">ğŸ”ˆ</button>
      </div>

      <input type="range" id="volumeSlider" class="volume-slider" min="0" max="1" step="0.01" value="0.5" title="ë³¼ë¥¨ ì¡°ì ˆ">

      <div class="right-controls">
        <button class="info-btn" id="infoBtn">â“˜</button>
        <button class="fullscreen-btn" id="fullscreenBtn">â›¶</button>
      </div>
    </header>

    <div class="project-info" id="projectInfo">
      <div class="project-info-content">
        <p class="info1">ë””ì§€í„¸ ê³¨ì½©ë“œ (Digital Golconda)</p>
        <p class="info">ì„ì´ì§€(ì´ê´„), ìœ ì •ë¯¼(ì•„íŠ¸), ë°°ì‹œìœ¨(í†µí•©), ì´ì§€ìœ¤(UI/UX)</p>
        <p class="info">ë””ì§€í„¸ ë””ìì¸ / 2025.12.01 ~ 2025.12.08</p>
      </div>
    </div>
    
    <div class="fullscreen-info" id="fullscreenInfo">
      <div class="fullscreen-time" id="fullscreenTime"></div>
    </div>
  </div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const toggleBtn = document.getElementById('playBtn');
    const toggleTime = document.getElementById('realtimeBtn');
    const themeSelect = document.getElementById('seasonSelect');
    const FullScreenBtn = document.getElementById('fullscreenBtn');

    let isRunning = true;
    let isRealTime = false;
    let isFullscreen = false;
    let fullscreenClockInterval = null;

    // UI ë²„íŠ¼ ì´ë²¤íŠ¸ (ì¬ìƒ/ì¼ì‹œì •ì§€)
    toggleBtn.addEventListener('click', () => {
        isRunning = !isRunning;
        if (isRunning) {
            toggleBtn.innerText = "â–¶";
            toggleBtn.style.background = "rgb(240, 240, 240)";
            toggleBtn.style.color = "black";
        } else {
            toggleBtn.innerText = "â¸";
            toggleBtn.style.background = "#e4716a";
            toggleBtn.style.color = "white";
        }
    });

    // ğŸ”„ ì‹¤ì‹œê°„/ìˆ˜ë™ ëª¨ë“œ í† ê¸€
    toggleTime.addEventListener('click', () => {
        isRealTime = !isRealTime;
        
        if (!isRealTime) {
            // [ìˆ˜ë™ ëª¨ë“œ ì „í™˜]
            toggleTime.innerText = "ìˆ˜ë™";
            
            const seasonTextEl = document.getElementById('currentSeasonText');
            const timeInfoEl = document.getElementById('timeInfo');
            if(seasonTextEl) seasonTextEl.textContent = "";
            if(timeInfoEl) timeInfoEl.textContent = "";

            themeSelect.disabled = false;
            canvas.className = ''; 
            currentTheme = themeSelect.value || 'spring'; 

        } else {
            // [ì‹¤ì‹œê°„ ëª¨ë“œ ì „í™˜]
            toggleTime.innerText = "ì‹¤ì‹œê°„";
            
            const initialSeason = getCurrentSeason();
            const initialTime = getTimeOfDay();

            applyTheme(initialSeason, initialTime);
            
            let sel3 = themeSelect.options;
            for (let i = 0; i < sel3.length; i++) {
                if (seasonThemes[initialSeason] && sel3[i].text == seasonThemes[initialSeason].name) {
                    sel3[i].selected = true;
                }
            }
            
            currentTheme = initialSeason;
            themeSelect.disabled = true;
        }
    });

    // ì‹œê°„ëŒ€ íŒë‹¨
    function getTimeOfDay() {
        const hour = new Date().getHours();
        if (hour >= 5 && hour < 7) return 'dawn';
        if (hour >= 7 && hour < 12) return 'morning';
        if (hour >= 12 && hour < 17) return 'day';
        if (hour >= 17 && hour < 19) return 'dusk';
        return 'night';
    }

    // ê³„ì ˆ íŒë‹¨
    function getCurrentSeason() {
        const now = new Date();
        const month = now.getMonth() + 1;
        if (month >= 3 && month <= 5) return 'spring';
        if (month >= 6 && month <= 8) return 'summer';
        if (month >= 9 && month <= 11) return 'autumn';
        return 'winter';
    }

    const timeThemes = {
        dawn: { name: 'ìƒˆë²½', bgColor: '#B2C1D7' },
        morning: { name: 'ì˜¤ì „', bgColor: '#B2C1D7' },
        day: { name: 'ì˜¤í›„', bgColor: '#B2C1D7' },
        dusk: { name: 'ì €ë…', bgColor: '#B2C1D7' },
        night: { name: 'ë°¤', bgColor: '#B2C1D7' }
    };

    const seasonThemes = {
        spring: { name: 'ë´„', baseColors: ['#FFB7C5', '#FF69B4', '#FFC0CB', '#FF1493'] },
        summer: { name: 'ì—¬ë¦„', baseColors: ['#4FC3F7', '#29B6F6', '#03A9F4', '#0288D1'] },
        autumn: { name: 'ê°€ì„', baseColors: ['#FF8A65', '#FF7043', '#F4511E', '#E64A19'] },
        winter: { name: 'ê²¨ìš¸', baseColors: ['#90CAF9', '#64B5F6', '#42A5F5', '#2196F3'] }
    };

    function applyTheme(season, timeOfDay) {
        const seasonTheme = seasonThemes[season];
        const timeTheme = timeThemes[timeOfDay];
        currentSeason = season;
        currentTimeOfDay = timeOfDay;
        
        const seasonTextEl = document.getElementById('currentSeasonText');
        const timeInfoEl = document.getElementById('timeInfo');

        if(isRealTime && seasonTextEl && seasonTheme) seasonTextEl.textContent = seasonTheme.name;
    }

    // ==========================================
    // ğŸ¨ [Zone A] ìƒ‰ìƒ ë° í…Œë§ˆ ê´€ë¦¬
    // ==========================================
    const themePalette = {
        spring: { skyTop: '#89C4F4', skyBottom: '#BAF1FF', wall: '#FFE4E1', roof: '#DB7093', windowFrame: '#FFF0F5', windowInner: '#FFE787', lighterWall: '#FFE8E5', drawStars: false },
        summer: { skyTop: '#4facfe', skyBottom: '#00f2fe', wall: '#F7FFE3', roof: '#207D57', windowFrame: '#A5C4AF', windowInner: '#CFFFFE', lighterWall: '#FCFFF0', drawStars: false },
        autumn: { skyTop: '#89C4F4', skyBottom: '#D6EAF8', wall: '#c4c4c4', roof: '#801830', windowFrame: '#e0e0e0', windowInner: '#89C4F4', lighterWall: '#d5d5d5', drawStars: false },
        winter: { skyTop: '#001133', skyBottom: '#1f3c6e', wall: '#c4c4c4', roof: '#801830', windowFrame: '#e0e0e0', windowInner: '#F2B370', lighterWall: '#d5d5d5', drawStars: true },
        rain: { skyTop: '#4facfe', skyBottom: '#00f2fe', wall: '#F7FFE3', roof: '#207D57', windowFrame: '#A5C4AF', windowInner: '#CFFFFE', lighterWall: '#FCFFF0', drawStars: false },
        Christmas: { skyTop: '#001133', skyBottom: '#1f3c6e', wall: '#c4c4c4', roof: '#801830', windowFrame: '#e0e0e0', windowInner: '#F2B370', lighterWall: '#d5d5d5', drawStars: true }
    };

    let currentTheme = 'spring';

    const stars = [];
    function initStars() {
        stars.length = 0;
        const numStars = 150;
        for (let i = 0; i < numStars; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: Math.random() * 1.5 + 0.5
            });
        }
    }
    initStars();

    // ==========================================
    // ğŸ–Šï¸ [Zone B] ê·¸ë¦¬ê¸° í•¨ìˆ˜ë“¤
    // ==========================================

    function drawBackground() {
        const palette = themePalette[currentTheme];
        if (!palette) return; 

        if (isRealTime) {
            const timeObj = timeThemes[getTimeOfDay()];
            const initialTime = timeObj ? timeObj.name : 'ì˜¤ì „';
            
            if (initialTime == "ìƒˆë²½") canvas.className = 'box1';
            else if (initialTime == "ì˜¤ì „") canvas.className = 'box2';
            else if (initialTime == "ì˜¤í›„") canvas.className = 'box3';
            else if (initialTime == "ì €ë…") canvas.className = 'box4';
            else if (initialTime == "ë°¤") canvas.className = 'box5';
        } 
        else if (currentTheme == "rain") {
            canvas.className = 'box5'; 
        } 
        else {
            canvas.className = ''; 
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, palette.skyTop);
            gradient.addColorStop(1, palette.skyBottom);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        if (palette.drawStars) {
            ctx.fillStyle = palette.windowInner;
            stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }
    }

    function drawSpring(ctx, x, y, size) {
        ctx.save();
        ctx.translate(x + size / 2, y + size / 2);
        ctx.fillStyle = "#FFB7C5";
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
            ctx.rotate((Math.PI * 2) / 5);
            ctx.ellipse(0, size / 5, size / 3, size / 2, 0, 0, Math.PI * 2);
        }
        ctx.fill();
        ctx.beginPath();
        ctx.arc(0, 0, size / 7, 0, Math.PI * 2);
        ctx.fillStyle = "#FFF";
        ctx.fill();
        ctx.restore();
    }

    function drawSummer(ctx, x, y, size) {
        ctx.save();
        ctx.translate(x + size / 2, y + size / 2);
        ctx.fillStyle = "#8B4513";
        ctx.beginPath();
        ctx.arc(0, 0, size / 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#FFD700";
        const petalCount = 12;
        for (let i = 0; i < petalCount; i++) {
            const angle = (Math.PI * 2 / petalCount) * i;
            const dist = size / 1.8;
            const px = Math.cos(angle) * dist;
            const py = Math.sin(angle) * dist;
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.ellipse(0, 0, size / 4, size / 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        ctx.restore();
    }

    function drawFall(ctx, x, y, size) {
        const baseSize = 30;
        const scale = size / baseSize;
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.fillStyle = "#d32f2f";
        ctx.beginPath();
        ctx.moveTo(0, -22); ctx.lineTo(6, -6); ctx.lineTo(16, -15); ctx.lineTo(10, 1);
        ctx.lineTo(20, 5); ctx.lineTo(8, 8);
        ctx.lineTo(-8, 8); ctx.lineTo(-20, 5);
        ctx.lineTo(-10, 1); ctx.lineTo(-16, -15); ctx.lineTo(-6, -6);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#7a1a1a";
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, -22); ctx.lineTo(0, 22); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(14, -12); ctx.moveTo(0, 5); ctx.lineTo(-14, -12);
        ctx.moveTo(0, 5); ctx.lineTo(12, 7); ctx.moveTo(0, 5); ctx.lineTo(-12, 7); ctx.stroke();
        ctx.restore();
    }

    function drawRoundedBranch(ctx, length, width) {
        ctx.beginPath();
        const radius = width / 2;
        ctx.arc(0, 0, radius, Math.PI / 2, -Math.PI / 2, true);
        ctx.rect(0, -radius, length, width);
        ctx.arc(length, 0, radius, -Math.PI / 2, Math.PI / 2);
        ctx.fill();
    }

    function drawWinter(ctx, x, y, size) {
        ctx.save();
        ctx.translate(x, y);
        const numBranches = 6;
        const mainBranchLength = size * 0.3;
        const secondaryBranchLength = size * 0.13;
        const branchWidth = size * 0.05;
        const centerRadius = size * 0.1;
        const angleOffset = Math.PI / 4;
        const branch1StartPos = mainBranchLength * 0.9;
        const branch2StartPos = mainBranchLength * 0.5;
        ctx.fillStyle = "#FFFFFF";
        for (let i = 0; i < numBranches; i++) {
            ctx.rotate((Math.PI * 2) / numBranches);
            ctx.save(); drawRoundedBranch(ctx, mainBranchLength, branchWidth);
            ctx.save(); ctx.translate(branch1StartPos, 0);
            ctx.save(); ctx.rotate(angleOffset); drawRoundedBranch(ctx, secondaryBranchLength, branchWidth); ctx.restore();
            ctx.save(); ctx.rotate(-angleOffset); drawRoundedBranch(ctx, secondaryBranchLength, branchWidth); ctx.restore();
            ctx.restore();
            ctx.save(); ctx.translate(branch2StartPos, 0);
            ctx.save(); ctx.rotate(angleOffset); drawRoundedBranch(ctx, secondaryBranchLength * 0.8, branchWidth); ctx.restore();
            ctx.save(); ctx.rotate(-angleOffset); drawRoundedBranch(ctx, secondaryBranchLength * 0.8, branchWidth); ctx.restore();
            ctx.restore();
            ctx.restore();
        }
        ctx.beginPath(); ctx.arc(0, 0, centerRadius, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }

    function drawrain(ctx, x, y, size) {
        const baseSize = 20;
        const scale = size / baseSize;
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.fillStyle = "#C9F9FF";
        ctx.beginPath();
        ctx.moveTo(0, -12);
        ctx.bezierCurveTo(-6, -7, -8, 1, -8, 7);
        ctx.bezierCurveTo(-8, 12, -5, 15, 0, 15);
        ctx.bezierCurveTo(5, 15, 8, 12, 8, 7);
        ctx.bezierCurveTo(8, 1, 6, -7, 0, -12);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    function drawSnowman(ctx, x, y, size) {
        ctx.save();
        const baseSize = 55;
        const scale = size / baseSize;
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        const offsetX = -64;
        const offsetY = -80;
        const bodyBaseX = 64 + offsetX;
        const bodyBaseY = 80 + offsetY;
        ctx.beginPath(); ctx.arc(bodyBaseX, bodyBaseY, 37, 0, Math.PI * 2); ctx.fillStyle = '#ececec'; ctx.fill();
        const headX = 64 + offsetX; const headY = 32 + offsetY;
        ctx.beginPath(); ctx.arc(headX, headY, 24, 0, Math.PI * 2); ctx.fillStyle = '#ececec'; ctx.fill();
        ctx.strokeStyle = '#6b4226'; ctx.lineCap = 'round'; ctx.lineWidth = 3.5;
        ctx.beginPath(); ctx.moveTo(35 + offsetX, 62 + offsetY); ctx.lineTo(18 + offsetX, 48 + offsetY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(95 + offsetX, 62 + offsetY); ctx.lineTo(110 + offsetX, 48 + offsetY); ctx.stroke();
        ctx.lineWidth = 3; ctx.beginPath();
        ctx.moveTo(16 + offsetX, 48 + offsetY); ctx.lineTo(11 + offsetX, 48 + offsetY);
        ctx.moveTo(18 + offsetX, 48 + offsetY); ctx.lineTo(17 + offsetX, 41 + offsetY);
        ctx.moveTo(110 + offsetX, 48 + offsetY); ctx.lineTo(117 + offsetX, 48 + offsetY);
        ctx.moveTo(110 + offsetX, 48 + offsetY); ctx.lineTo(111 + offsetX, 41 + offsetY); ctx.stroke();
        ctx.fillStyle = '#333';
        ctx.beginPath(); ctx.arc(64 + offsetX, 95 + offsetY, 3.8, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(64 + offsetX, 79 + offsetY, 3.8, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(54 + offsetX, 30 + offsetY, 3, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(74 + offsetX, 30 + offsetY, 3, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#f4a23a'; ctx.beginPath(); ctx.arc(64 + offsetX, 35 + offsetY, 3, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = "#333"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(56 + offsetX, 41 + offsetY);
        ctx.bezierCurveTo(60 + offsetX, 45 + offsetY, 68 + offsetX, 45 + offsetY, 72 + offsetX, 41 + offsetY); ctx.stroke();
        ctx.restore();
    }

    const themeDrawFunctions = {
        'spring': drawSpring,
        'summer': drawSummer,
        'autumn': drawFall,
        'winter': drawWinter,
        'rain': drawrain,
        'Christmas': drawSnowman
    };

    // ==========================================
    // ğŸ™ï¸ [Background] ê±´ë¬¼ ê·¸ë¦¬ê¸°
    // ==========================================
    function drawBuildings(ctx) {
        const palette = themePalette[currentTheme] || themePalette['spring'];

        const wallColor = palette.wall;
        const roofColor = palette.roof;
        const windowColor = palette.windowFrame;
        const innerColor = palette.windowInner;
        const lighterWallColor = palette.lighterWall;

        const mainBuildingBaseY = 400;
        const mainBuildingHeight = 360;
        const mainBuildingWidth = 600;
        const rightBuildingWidth = 200;

        ctx.fillStyle = wallColor;
        ctx.fillRect(0, mainBuildingBaseY, mainBuildingWidth, mainBuildingHeight);
        ctx.fillStyle = roofColor;
        ctx.beginPath(); ctx.moveTo(0, mainBuildingBaseY); ctx.lineTo(0, mainBuildingBaseY - 45); ctx.lineTo(100, mainBuildingBaseY - 45); ctx.lineTo(100, mainBuildingBaseY); ctx.fill();
        ctx.beginPath(); ctx.moveTo(50, mainBuildingBaseY - 60); ctx.lineTo(250, mainBuildingBaseY - 60); ctx.lineTo(250, mainBuildingBaseY); ctx.lineTo(10, mainBuildingBaseY); ctx.fill();
        ctx.beginPath(); ctx.moveTo(260, mainBuildingBaseY - 35); ctx.lineTo(380, mainBuildingBaseY - 35); ctx.lineTo(380, mainBuildingBaseY + 15); ctx.lineTo(250, mainBuildingBaseY + 15); ctx.fill();
        ctx.beginPath(); ctx.fillStyle = wallColor; ctx.moveTo(250, mainBuildingBaseY - 60); ctx.lineTo(260, mainBuildingBaseY - 60); ctx.lineTo(260, mainBuildingBaseY - 35); ctx.lineTo(250, mainBuildingBaseY + 15); ctx.fill();
        ctx.fillStyle = roofColor; ctx.beginPath(); ctx.moveTo(380, mainBuildingBaseY); ctx.lineTo(380, mainBuildingBaseY - 50); ctx.lineTo(600, mainBuildingBaseY - 50); ctx.lineTo(600, mainBuildingBaseY); ctx.fill();
        ctx.fillStyle = windowColor; ctx.beginPath(); ctx.moveTo(70, mainBuildingBaseY + 15); ctx.lineTo(140, mainBuildingBaseY - 35); ctx.lineTo(210, mainBuildingBaseY + 15); ctx.fill();
        ctx.fillStyle = wallColor; ctx.beginPath(); ctx.moveTo(90, mainBuildingBaseY + 15); ctx.lineTo(140, mainBuildingBaseY - 20); ctx.lineTo(190, mainBuildingBaseY + 15); ctx.fill();
        ctx.beginPath(); ctx.fillStyle = windowColor; ctx.moveTo(0, mainBuildingBaseY + 15); ctx.lineTo(90, mainBuildingBaseY + 15); ctx.lineTo(90, mainBuildingBaseY); ctx.lineTo(0, mainBuildingBaseY); ctx.fill();
        ctx.fillStyle = windowColor; ctx.beginPath(); ctx.arc(140, mainBuildingBaseY + 5, 10, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = innerColor; ctx.beginPath(); ctx.arc(140, mainBuildingBaseY + 5, 6, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.fillStyle = windowColor; ctx.moveTo(250, mainBuildingBaseY + 15); ctx.lineTo(190, mainBuildingBaseY + 15); ctx.lineTo(190, mainBuildingBaseY); ctx.lineTo(250, mainBuildingBaseY); ctx.fill();
        ctx.beginPath(); ctx.fillStyle = windowColor; ctx.moveTo(380, mainBuildingBaseY + 15); ctx.lineTo(250, mainBuildingBaseY + 15); ctx.lineTo(250, mainBuildingBaseY + 30); ctx.lineTo(380, mainBuildingBaseY + 30); ctx.fill();
        ctx.beginPath(); ctx.fillStyle = windowColor; ctx.moveTo(600, mainBuildingBaseY + 15); ctx.lineTo(380, mainBuildingBaseY + 15); ctx.lineTo(380, mainBuildingBaseY); ctx.lineTo(600, mainBuildingBaseY); ctx.fill();
        ctx.fillStyle = lighterWallColor; ctx.fillRect(600, 0, rightBuildingWidth, canvas.height);

        function drawWindow(x, y, width, height) {
            ctx.fillStyle = windowColor; ctx.fillRect(x, y, width, height);
            ctx.fillStyle = innerColor;
            ctx.fillRect(x + 5, y + 5, width - 22, height - 45);
            ctx.fillRect(x + 17, y + 5, width - 22, height - 45);
            ctx.fillRect(x + 5, y + 25, width - 22, height - 30);
            ctx.fillRect(x + 17, y + 25, width - 22, height - 30);
            ctx.fillStyle = windowColor; ctx.fillRect(x - 2, y + 60, width + 4, 5);
        }

        function drawbigWindow(x, y, width, height) {
            const bigframeColor = windowColor; const biginnerColor = innerColor;
            ctx.fillStyle = bigframeColor; ctx.fillRect(x, y, width, height);
            const innerX = x + 10; const innerY = y + 10; const innerWidth = width - 20; const innerHeight = height - 20;
            ctx.fillStyle = biginnerColor; ctx.fillRect(innerX, innerY, innerWidth, innerHeight);
            const dividerWidth = 10; const dividerX = innerX + (innerWidth / 2) - (dividerWidth / 2);
            ctx.fillStyle = bigframeColor; ctx.fillRect(dividerX, innerY, dividerWidth, innerHeight);
            const dividerHeight = 10; const dividerY = innerY + (innerHeight / 2) - (dividerHeight / 2);
            ctx.fillStyle = bigframeColor; ctx.fillRect(innerX, dividerY, innerWidth, dividerHeight);
        }

        const windowWidth = 30; const windowHeight = 60; const windowGapX = 30; const windowGapY = 30;
        let startY = mainBuildingBaseY + 30; let startX = 65;
        for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 3; j++) {
                drawWindow(startX + (windowWidth + windowGapX) * j, startY + (windowHeight + windowGapY) * i, windowWidth, windowHeight);
            }
        }
        startX = 270; const startY2 = mainBuildingBaseY + 60;
        for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 2; j++) {
                drawWindow(startX + (windowWidth + windowGapX) * j, startY2 + (windowHeight + windowGapY) * i, windowWidth, windowHeight);
            }
        }
        startX = 415;
        for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 3; j++) {
                drawWindow(startX + (windowWidth + windowGapX) * j, startY + (windowHeight + windowGapY) * i, windowWidth, windowHeight);
            }
        }
        const rightWindowWidth = 100; const rightWindowHeight = 150;
        startX = 650; let currentY = -60;
        for (let i = 0; i < 3; i++) {
            drawbigWindow(startX, currentY, rightWindowWidth, rightWindowHeight + 50);
            currentY += rightWindowHeight + 130;
        }
    }

    // ==========================================
    // âš™ï¸ [Engine] ë‚™í•˜ ë¡œì§ ë° ì´ë²¤íŠ¸
    // ==========================================
    
    themeSelect.addEventListener('change', (e) => {
        currentTheme = e.target.value;
        if(currentTheme !== 'rain') {
            canvas.className = '';
        }
    });

    const config = { columnCount: 8, rowGap: 200, baseSpeed: 0.8 };
    const drops = [];

    class Drop {
        constructor(colIndex, rowIndex, columnWidth, totalRows, layer) {
            this.layer = layer;
            let speedMultiplier = 1.0;
            if (layer === 2) {
                this.size = 30; this.zIndex = 2; this.offsetX = 0; this.offsetY = 0; speedMultiplier = 1.0;
            } else if (layer === 1) {
                this.size = 20; this.zIndex = 1; this.offsetX = columnWidth / 2; this.offsetY = config.rowGap / 2; speedMultiplier = 0.6;
            } else {
                this.size = 12; this.zIndex = 0; this.offsetX = columnWidth / 3; this.offsetY = config.rowGap / 3; speedMultiplier = 0.3;
            }
            this.speed = config.baseSpeed * speedMultiplier;
            this.rowGap = config.rowGap;
            this.totalRows = totalRows;
            this.x = (colIndex * columnWidth) + (columnWidth / 2) - (this.size / 2) + this.offsetX;
            let baseY = rowIndex * this.rowGap;
            if (colIndex % 2 !== 0) baseY += (this.rowGap / 2);
            this.y = baseY - 200 + this.offsetY;
        }

        update() {
            if (!isRunning) return;
            this.y += this.speed;
            const patternHeight = this.totalRows * this.rowGap;
            const threshold = canvas.height + 150;
            if (this.y > threshold) {
                this.y -= patternHeight;
            }
        }

        draw() {
            const drawFunc = themeDrawFunctions[currentTheme];
            if (drawFunc) {
                drawFunc(ctx, this.x, this.y, this.size);
            }
        }
    }

    function init() {
        drops.length = 0;
        const rowsNeeded = Math.ceil(canvas.height / config.rowGap) + 3;
        for (let layer = 0; layer < 3; layer++) {
            let layerColCount;
            if (layer === 0) layerColCount = 20;
            else layerColCount = config.columnCount;
            const currentColumnWidth = canvas.width / layerColCount;
            for (let col = 0; col < layerColCount; col++) {
                for (let row = 0; row < rowsNeeded; row++) {
                    drops.push(new Drop(col, row, currentColumnWidth, rowsNeeded, layer));
                }
            }
        }
    }

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        drops.forEach(drop => { if (drop.layer === 0) { drop.update(); drop.draw(); } });
        drawBuildings(ctx);
        drops.forEach(drop => { if (drop.layer > 0) { drop.update(); drop.draw(); } });
        requestAnimationFrame(animate);
    }

    init();
    animate();

    function resizeCanvas() { }

    function updateFullscreenInfo() {
        const now = new Date();
        const hour = now.getHours();
        const minute = now.getMinutes();
        const period = hour < 12 ? 'ì˜¤ì „' : 'ì˜¤í›„';
        const hour12 = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
        const timeString = `${period} ${hour12}:${minute.toString().padStart(2, '0')}`;
        const fullscreenTimeEl = document.getElementById('fullscreenTime');
        if (fullscreenTimeEl) {
            fullscreenTimeEl.textContent = timeString;
        }
    }

    setInterval(() => {
        if (isRealTime) {
            const detectedSeason = getCurrentSeason();
            const detectedTime = getTimeOfDay();
            if (detectedSeason !== currentSeason || detectedTime !== currentTimeOfDay) {
                applyTheme(detectedSeason, detectedTime);
            }
        }
    }, 60000);

    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const fullscreenInfo = document.getElementById('fullscreenInfo');

    fullscreenBtn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().then(() => {
                isFullscreen = true;
                document.body.classList.add('fullscreen-mode');
                fullscreenInfo.classList.add('show');
                resizeCanvas();
                startFullscreenClock();
            });
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen().then(() => {
                    isFullscreen = false;
                    document.body.classList.remove('fullscreen-mode');
                    fullscreenInfo.classList.remove('show');
                    stopFullscreenClock();
                    resizeCanvas();
                });
            }
        }
    });

    document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement) {
            isFullscreen = false;
            document.body.classList.remove('fullscreen-mode');
            fullscreenInfo.classList.remove('show');
            stopFullscreenClock();
            resizeCanvas();
        }
    });

    function startFullscreenClock() {
        updateFullscreenInfo();
        if (fullscreenClockInterval) clearInterval(fullscreenClockInterval);
        const now = new Date();
        const seconds = now.getSeconds();
        const msUntilNextMinute = (60 - seconds) * 1000 - now.getMilliseconds();
        setTimeout(() => {
            updateFullscreenInfo();
            fullscreenClockInterval = setInterval(() => {
                updateFullscreenInfo();
            }, 60000);
        }, msUntilNextMinute);
    }

    function stopFullscreenClock() {
        if (fullscreenClockInterval) {
            clearInterval(fullscreenClockInterval);
            fullscreenClockInterval = null;
        }
    }

    const infoBtn = document.getElementById('infoBtn');
    const projectInfo = document.getElementById('projectInfo');
    let isInfoVisible = false;

    infoBtn.addEventListener('click', () => {
        isInfoVisible = !isInfoVisible;
        if (isInfoVisible) {
            projectInfo.classList.add('show');
            infoBtn.style.background = '#6eb36e';
            infoBtn.style.color = 'white';
        } else {
            projectInfo.classList.remove('show');
            infoBtn.style.background = 'rgb(240, 240, 240)';
            infoBtn.style.color = 'black';
        }
    });

    document.addEventListener('click', (e) => {
        if (isInfoVisible && !projectInfo.contains(e.target) && e.target !== infoBtn) {
            isInfoVisible = false;
            projectInfo.classList.remove('show');
            infoBtn.style.background = 'rgb(240, 240, 240)';
            infoBtn.style.color = 'black';
        }
    });

    // ==========================================
    // ğŸ”Š ì†Œë¦¬ ë° ë³¼ë¥¨ ì œì–´ ë¡œì§
    // ==========================================
    let currentAudio = null;
    let isSoundOn = true;
    let globalVolume = 0.5; // ê¸°ë³¸ ë³¼ë¥¨

    const soundFiles = {
        forest: 'forest.mp3',
        bird: 'bird.mp3',
        ocean: 'ocean.mp3',
        fallen_leaves: 'fallen_leaves.mp3',
        rain: 'rain.mp3',
       
        bonfire: 'bonfire.mp3',
        restanrant: 'restanrant.mp3',
        cafe: 'cafe.mp3'
    };

    function playSound(soundType) {
        if (currentAudio) {
            currentAudio.pause();
            currentAudio = null;
        }
        if (!isSoundOn) return;
        if (soundFiles[soundType]) {
            currentAudio = new Audio(soundFiles[soundType]);
            currentAudio.loop = true;
            currentAudio.volume = globalVolume; // ì„¤ì •ëœ ë³¼ë¥¨ ì ìš©
            currentAudio.play().catch(err => {
                console.log('ì†Œë¦¬ ì¬ìƒ ì‹¤íŒ¨:', err);
            });
        }
    }

const soundSelect = document.getElementById('soundSelect');
soundSelect.addEventListener('change', (e) => {
if (e.target.value !== 'spring') { // 'ì†Œë¦¬ ì„ íƒ' ì˜µì…˜ì´ ì•„ë‹ ë•Œë§Œ
playSound(e.target.value);
}
});

// ì†Œë¦¬ on/off ë²„íŠ¼ ì´ë²¤íŠ¸
const soundBtn = document.getElementById('soundBtn');
soundBtn.addEventListener('click', () => {
isSoundOn = !isSoundOn;
if (isSoundOn) {
soundlcon.src = "on.svg";
soundBtn.style.background = "rgb(240, 240, 240)";
// í˜„ì¬ ì„ íƒëœ ì†Œë¦¬ ì¬ìƒ
if (soundSelect.value !== 'spring') {
playSound(soundSelect.value);
}
} else {
soundlcon.src = "off.svg";
soundBtn.style.background = "#e4716a";
// ì†Œë¦¬ ì •ì§€
if (currentAudio) {
currentAudio.pause();
}
}
});


    // ğŸ’¡ ë³¼ë¥¨ ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸
    const volumeSlider = document.getElementById('volumeSlider');
    volumeSlider.addEventListener('input', (e) => {
        globalVolume = e.target.value; // ë³¼ë¥¨ ê°’ ì—…ë°ì´íŠ¸ (0.0 ~ 1.0)
        
        // í˜„ì¬ ì¬ìƒ ì¤‘ì¸ ì˜¤ë””ì˜¤ê°€ ìˆë‹¤ë©´ ì¦‰ì‹œ ë³¼ë¥¨ ë°˜ì˜
        if (currentAudio) {
            currentAudio.volume = globalVolume;
        }
  // ë§Œì•½ ë³¼ë¥¨ì´ 0ì´ë©´ ìŒì†Œê±° ì•„ì´ì½˜ìœ¼ë¡œ ë³€ê²½ (UX ì˜µì…˜)
        if(globalVolume == 0) {
             soundBtn.innerText = "off.svg";
        } else if(isSoundOn) {
             soundBtn.innerText = "on.svg";
        }
       
    });

</script>
</body>
</html>